#version 300 es


#ifdef GL_ES
precision highp float;
#endif //GL_ES

layout (location = 0) out vec4 rtFragColor;
//out vec4 rtFragColor;
uniform sampler2D uTexture;

// VARYING
// PER-VERTEX: recieve final color
in vec4 vColor;

//PER-FRAGMENT: recieving stuff used for final color
in vec4 vNormal;

in vec4 vTexcoord;
in vec4 vLightPos1;
in vec4 vLightPos2;
in vec3 raypos;
in vec4 vPosition;

// calcLighting: calculates Lambertian and Blinn-Phong reflectance, and returns part of the summation of the final color
//    light: the current Point Light
//    position:     point on the sphere that we are drawing
//    normal:       normal vector from point
//    rayOrigin:    input ray origin
//	  viewVector:	vector from point to camera
vec4 calcLighting (in vec4 lightpos, in vec4 lightcolor, float lightintense, in vec4 position,
                   in vec3 normal, in vec3 rayOrigin)
{
    //Taken from Lab 4
    // LAMBERTIAN REFLECTANCE
    vec3 lightVector = lightpos.xyz - position.xyz; // get vector of position to the light
	float lightLength = length(lightVector); // get length of light vector
    lightVector = lightVector / lightLength; // normalizes vector
   
    float diffuseCoefficient = max(0.0, dot(lightVector, normal)); // get coefficient
   
    float intensityRatio = lightLength/lightintense; // simplifying attenuation equation by doing this once
    float attenuation = 1.0 / (1.0 + intensityRatio +
                             (intensityRatio * intensityRatio)); // get attenuation
    float Lambertian = diffuseCoefficient * attenuation; // final lambertian

   // PHONG REFLECTANCE
        
    vec3 viewVector = normalize(rayOrigin.xyz - position.xyz);
    vec3 reflectedLightVector =reflect(-normalize(lightVector).xyz, 
                                           normal.xyz);
    float specular = max(0.0, dot(viewVector, reflectedLightVector));
    specular *= specular; // specularCoefficient^2
    specular *= specular; // specularCoefficient^4
    specular *= specular * specular * specular; // specularCoefficient^16
    specular *= specular * specular * specular; // specularCoefficient^64
   //return vec4(specularCoefficient);
    vec4 ambient = vec4(0.3,0.3,0.3,0.0);
        
    return ambient * 0.15 + (Lambertian * texture(uTexture,vTexcoord.xy*2.0*vec2(-1.0,1.0)) + specular) * lightcolor; //Phong color
}

void main()
{
	//rtFragColor = vec4(0.5, 0.0, 0.25, 1.0);
	
	//PER-VERTEX: input is just final color
	rtFragColor = vColor;
	
	//PER-FRAGMENT: calulate final color here using inputs
	rtFragColor = calcLighting(vLightPos1,vec4(1.0),10.0,vPosition,vNormal.xyz,raypos)
	+calcLighting(vLightPos2,vec4(1.0),5.0,vPosition,vNormal.xyz,raypos);	
	
	


	
//rtFragColor = calcLighting(vec4(0.0),vec4(0.0),0.0,vec3(0.0),vec3(0.0),vec3(0.0));
}
/*
	Copyright 2020 Demetrius J Nekos

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at
		http://www.apache.org/licenses/LICENSE-2.0
	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/

// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN

//------------------------------------------------------------
// TYPE ALIASES & UTILITY FUNCTIONS

// sScalar: alias for a 1D scalar (non-vector)
#define sScalar float

// sCoord: alias for a 2D coordinate
#define sCoord vec2

// sDCoord: alias for a 2D displacement or measurement
#define sDCoord vec2

// sBasis: alias for a 3D basis vector
#define sBasis vec3

// sPoint: alias for a point/coordinate/location in space
#define sPoint vec4

// sVector: alias for a vector/displacement/change in space
#define sVector vec4


// color3: alias for a 3D vector representing RGB color
// 	(this is non-spatial so neither a point nor vector)
#define color3 vec3

// color4: alias for RGBA color, which is non-spatial
// 	(this is non-spatial so neither a point nor vector)
#define color4 vec4


// asPoint: promote a 3D vector into a 4D vector 
//	representing a point in space (w=1)
//    v: input 3D vector to be converted
sPoint asPoint(in sBasis v)
{
    return sPoint(v, 1.0);
}

// asVector: promote a 3D vector into a 4D vector 
//	representing a vector through space (w=0)
//    v: input 3D vector to be converted
sVector asVector(in sBasis v)
{
    return sVector(v, 0.0);
}


// lengthSq: calculate the squared length of a vector type
sScalar lengthSq(sDCoord x)
{
    return dot(x, x);
}
sScalar lengthSq(sBasis x)
{
    return dot(x, x);
}
sScalar lengthSq(sVector x)
{
    return dot(x, x);
}


//------------------------------------------------------------
// VIEWPORT INFO

// sViewport: info about viewport
//    viewportPoint: location on the viewing plane 
//							x = horizontal position
//							y = vertical position
//							z = plane depth (negative focal length)
//	  pixelCoord:    position of pixel in image
//							x = [0, width)	-> [left, right)
//							y = [0, height)	-> [bottom, top)
//	  resolution:    resolution of viewport
//							x = image width in pixels
//							y = image height in pixels
//    resolutionInv: resolution reciprocal
//							x = reciprocal of image width
//							y = reciprocal of image height
//	  size:       	 in-scene dimensions of viewport
//							x = viewport width in scene units
//							y = viewport height in scene units
//	  ndc: 			 normalized device coordinate
//							x = [-1, +1) -> [left, right)
//							y = [-1, +1) -> [bottom, top)
// 	  uv: 			 screen-space (UV) coordinate
//							x = [0, 1) -> [left, right)
//							y = [0, 1) -> [bottom, top)
//	  aspectRatio:   aspect ratio of viewport
//	  focalLength:   distance to viewing plane
struct sViewport
{
    sPoint viewportPoint;
	sCoord pixelCoord;
	sDCoord resolution;
	sDCoord resolutionInv;
	sDCoord size;
	sCoord ndc;
	sCoord uv;
	sScalar aspectRatio;
	sScalar focalLength;
};

// initViewport: calculate the viewing plane (viewport) coordinate
//    vp: 		      output viewport info structure
//    viewportHeight: input height of viewing plane
//    focalLength:    input distance between viewer and viewing plane
//    fragCoord:      input coordinate of current fragment (in pixels)
//    resolution:     input resolution of screen (in pixels)
void initViewport(out sViewport vp,
                  in sScalar viewportHeight, in sScalar focalLength,
                  in sCoord fragCoord, in sDCoord resolution)
{
    vp.pixelCoord = fragCoord;
    vp.resolution = resolution;
    vp.resolutionInv = 1.0 / vp.resolution;
    vp.aspectRatio = vp.resolution.x * vp.resolutionInv.y;
    vp.focalLength = focalLength;
    vp.uv = vp.pixelCoord * vp.resolutionInv;
    vp.ndc = vp.uv * 2.0 - 1.0;
    vp.size = sDCoord(vp.aspectRatio, 1.0) * viewportHeight;
    vp.viewportPoint = asPoint(sBasis(vp.ndc * vp.size * 0.5, -vp.focalLength));
}


//------------------------------------------------------------
// RAY INFO

// sRay: ray data structure
//	  origin: origin point in scene
//    direction: direction vector in scene
struct sRay
{
    sPoint origin;
    sVector direction;
};

// initRayPersp: initialize perspective ray
//    ray: 		   output ray
//    eyePosition: position of viewer in scene
//    viewport:    input viewing plane offset
void initRayPersp(out sRay ray,
             	  in sBasis eyePosition, in sBasis viewport)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    ray.origin = asPoint(eyePosition);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    ray.direction = asVector(viewport - eyePosition);
}

// initRayOrtho: initialize orthographic ray
//    ray: 		   output ray
//    eyePosition: position of viewer in scene
//    viewport:    input viewing plane offset
void initRayOrtho(out sRay ray,
             	  in sBasis eyePosition, in sBasis viewport)
{
    // offset eye position to point on plane at the same depth
    initRayPersp(ray, eyePosition + sBasis(viewport.xy, 0.0), viewport);
}

// Effect1: returns two textures with a horizontal fade between them
//    channel1: the leftmost texture
//    channel2: the rightmost texture
//    loc:      position
color4 Effect1(in sampler2D channel1, in sampler2D channel2, sCoord loc)
{
    //loc.x -= 0.5; // centering the textures
    return mix(texture(iChannel0, loc),texture(iChannel1, loc),vec4(loc.x)); // return mix of the two, fading on x axis
}

// Effect2: returns a texture with barrel distortion laid on top
//    channel: the texture to grap colors from
//    uv:      normalized position
color4 Effect2(in sampler2D channel, in vec2 uv)
{    
    // some code from https://www.geeks3d.com/20140213/glsl-shader-library-fish-eye-and-dome-and-barrel-distortion-post-processing-filters/2/
    vec2 p = uv-0.5; // make center the origin
    float theta  = atan(p.y, p.x); // get theta for centering it as a circle
    float length_p = length(p); // length of p
    float radius = length_p * length_p; // get radius of point in circle
    p.x = radius * cos(theta); // distort x based on length/radius
    p.y = radius * sin(theta); // distort y based on length/radius
    return texture(channel, p + 0.5); // re-center and get texture
}

// Effect3: returns texture with lighting from a point light using Lambertian lighting
// channel: the texture to grap colors from
// vp:      viewport, used for uv
// time:    iTime
color4 Effect3(in sampler2D channel, in sViewport vp, float time)
{
    vec3 position = vec3(vp.uv.x,vp.uv.y,0.0); // position in space
    vec3 normal = vec3(0.0,0.0,1.0); // normal vector to plane
    
    vec3 lightpos = vec3(cos(time) * 0.3 + 0.5, sin(time) * 0.3 + 0.5, 0.15);
    float intensity = 3.0;
    
    // taken from Lab 4
    vec3 lightVector = lightpos - position; // get vector of position to the light
	float lightLength = length(lightVector); // get length of light vector
    lightVector = lightVector / lightLength; // normalizes vector
   
    float diffuseCoefficient = max(0.0, dot(lightVector, normal)); // get coefficient
   
    float intensityRatio = lightLength/intensity; // simplifying attenuation equation by doing this once
    float attenuation = 1.0 / (1.0 + intensityRatio +
                             (intensityRatio * intensityRatio)); // get attenuation
    return diffuseCoefficient * attenuation * texture(channel, vp.uv); // final lambertian
    
}

// Effect4: returns color from cubemap that spins and is distorted
// channel: the cubemap
// vp:      viewport, used for uv
// time:    iTime
// ray:     ray pointing towards cubemap
color4 Effect4(in samplerCube channel, in sViewport vp, in sRay ray, float time)
{   
    //distort and move
    vec3 p = ray.direction.xyz-0.5; // make center the origin
    float theta  = atan(p.y, p.x); // get theta for centering it as a circle
    float length_p = length(p.xy); // length of p
    float radius = length_p * length_p; // get radius of point in circle
    p.x = radius * cos(theta); // distort x based on length/radius
    p.y = radius * sin(theta); // distort y based on length/radius
	p = p + 0.6; // recenter
    //return texture(channel,vec3(p.x,p.y,0.5));
    
    // rotation and distort
    return texture(channel,vec3(p.x * cos(time) + p.z * sin(time),
                                p.y,
                                p.z *cos(time) -p.x * sin(time)));
    
    
    // moves up/down
	//return texture(channel,vec3(vp.uv.x,vp.uv.y + sin(iTime),1.0));//* sign(sin(iTime))));
	
    // rotates
    //return texture(channel,vec3(ray.direction.x * cos(time) + ray.direction.z * sin(time),
    //                            ray.direction.y,
    //                            ray.direction.z *cos(time) -ray.direction.x * sin(time)));
}

// Effect4Bonus: returns color from cubemap that moves with mouse
// channel: the cubemap
// vp:      viewport, used for uv
// time:    iTime
// mouse:   position from mouse
color4 Effect4Bonus(in samplerCube channel, in sViewport vp, vec2 mouse)
{
    // credit to 2Light for code samples from https://www.shadertoy.com/view/4tBSz1
    vp.uv = vp.uv - vec2(0.5); // center image
    vp.uv.x *= vp.aspectRatio; // fix aspect ratio
	
    vec2 mo = (mouse.xy/vp.resolution.xy); // get normalized mouse
    // adjust mouse sensitivity
	float rotX = mo.x*6.28; // Pi * 2 for 360 deg rotation around Y axis (left and right)
	float rotY = mo.y*3.14; // Pi for 180 degree up and down

    vec3 cam = -vec3(sin(rotY) * cos(rotX), cos(rotY), sin(rotX) * sin(rotY)); // mouse's vector pointing from vp to point on cubemap
    vec3 yaxis =  normalize(cross(vec3(0.0, 1.0, 0.0), cam)); // invert y axis
    vec3 xaxis = cross(cam, yaxis);
    return texture(channel,cam + yaxis * vp.uv.x + xaxis * vp.uv.y);
}

//------------------------------------------------------------
// RENDERING FUNCTIONS

// calcColor: calculate the color of current pixel
//	  vp:       input viewport info
//	  ray:      input ray info
//    time:     iTime
//    channel0: iChannel0
//    channel0: iChannel1
//    cubemap:  iChannel2
//	  mouse:    iMouse.xy
color4 calcColor(in sViewport vp, in sRay ray, in float time, in sampler2D channel0, in sampler2D channel1, in samplerCube cubemap, in vec2 mouse)
{
    // test inputs
    //return color4(ray.direction.xyz == vp.viewportPoint.xyz); // pass
    //return color4(lengthSq(vp.viewportPoint.xy) >= 0.25); // pass
    //return color4(vp.uv, 0.0, 0.0);
    //return color4(vp.ndc, 0.0, 0.0);
    //return vp.viewportPoint;
    
    // const color
    //return vec4(1.0,0.5,0.0,1.0);
    
    // texture (full-screen)
    //sampler2D tex = iChannel0;
    
    sCoord px = vp.pixelCoord; // 
    sDCoord res = iChannelResolution[0].xy; // using channel 0 as they have the same resolution
    sScalar ratio = res.y * vp.resolutionInv.y; // ratio of texture and viewport
    sCoord loc = px / res * ratio; // get location of point on texture
    //return Effect1(channel0, channel1,loc); // return mix of the two, fading on x axis
    //return Effect2(iChannel0, vp.uv);
    //return Effect3(channel0,vp, time);
    return Effect4(iChannel2, vp, ray, time);
    //return Effect4Bonus(iChannel2,vp, mouse);

    //return texture(channel0, loc);
}


//------------------------------------------------------------
// SHADERTOY MAIN

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out color4 fragColor, in sCoord fragCoord)
{
    // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
    fragColor += calcColor(vp, ray, iTime,iChannel0,iChannel1,iChannel2,iMouse.xy);
}